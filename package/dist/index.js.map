{"version":3,"sources":["../lib/index.js"],"names":["scope","self","window","global","Error","checkRules","rules","forEach","rule","value","isSet","s","Object","prototype","toString","call","checkSet","set","constructor","Set","name","checkSets","sets","every","checkArgsLength","args","length","arbitraryToBinary","arbitraryFunc","binaryFunc","originals","add","has","rulesFct","resolve","obj","circ","Array","from","fctObj","fctStr","String","replace","refs","getOwnPropertyNames","map","key","isArray","el","copy","sort","a","b","localeCompare","valType","iterator","values","element","next","undefined","elType","setCompare","equal","sortedElmnt","sortedValue","JSON","stringify","toArray","out","size","count","any","randomElement","randomElementUnary","array","randomIndex","Math","floor","random","isSupersetOf","isSubsetOf","properSupersetOf","isProperSupersetOf","properSubsetOf","isProperSubsetOf","isEmpty","isEmptyUnary","elements","original","toSet","c","union","unionArbitrary","set3","intersection","intersectionArbitrary","minimumSet","reduce","prev","curr","compare","intersect","difference","set1","set2","complement","symDiff","addToSet","source","target","symmetricDifference","arg","shift","cartesian","cartesianProduct","value1","value2","subsets","S","output","it","result","done","e","eSet","diff","subs","entry","power","powerSet","mergeRulesAny","strict","targetFn","some","passed","mergeRules","mergeRulesStrict","__isExtended__"],"mappings":"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","sourcesContent":["// //////////////////////////////////////////////////////////////////////////////// //\n// MIT License\n//\n// Copyright (c) 2018 Jan Küster\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n//   The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n// //////////////////////////////////////////////////////////////////////////////// //\n/* global self */\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// INTERNAL                                                                         //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * @private detect current environment's globalThis to enable cross-env usage\n */\nconst scope = (() => {\n  if (typeof self !== 'undefined') { return self }\n  if (typeof window !== 'undefined') { return window }\n  if (typeof global !== 'undefined') { return global }\n  throw new Error('unable to locate global object')\n})()\n\n/**\n * @private checks all rules in list tro be a function @private\n */\nconst checkRules = (rules) => {\n  rules.forEach(rule => {\n    if (typeof rule !== 'function') {\n      throw new Error(`Expected [rule] to be typeof [function], got [${typeof value}]`)\n    }\n  })\n  return true\n}\n\n/**\n * @private checks, whether an Object is a Set\n * @return {boolean}\n */\nconst isSet = s => Object.prototype.toString.call(s) === '[object Set]'\n\n/**\n * @private checks, whether a given value is a Set instance @private\n */\nconst checkSet = (set) => {\n  if (!set || !set.constructor || !isSet(set) || !(set instanceof scope.Set)) {\n    throw new Error(`Expected [set] to be instanceof [${scope.Set.name}], got [${set && set.constructor}]`)\n  }\n  return true\n}\n\n/**\n * @private checks all values to be a Set-instance @private\n */\nconst checkSets = (sets) => sets.every(s => checkSet(s))\n\n/**\n * @private checks arguments length and raises error if not given length\n */\nconst checkArgsLength = (args, length = 1) => {\n  if (!args || args.length !== length) {\n    throw new Error(`The function must be given exactly ${length} argument.`)\n  }\n  return true\n}\n\n/**\n * A decorator which, given an arbitrary set function,\n * produces the corresponding binary operation.\n * @private\n */\nconst arbitraryToBinary = (arbitraryFunc) => {\n  return function binaryFunc (...args) {\n    checkArgsLength(args, 1)\n    const set = args[0]\n    return arbitraryFunc(this, set)\n  }\n}\n\n/**\n * @private contains references to the original Set functions\n */\nconst originals = {\n  /**\n   * @private The original Set reference.\n   */\n  constructor: scope.Set,\n  /**\n   * @private The original add function.\n   */\n  add: scope.Set.prototype.add,\n\n  /**\n   * @private The original has function reference.\n   */\n  has: scope.Set.prototype.has\n}\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// OVERRIDES                                                                        //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\nscope.Set.prototype.add =\n\n  /**\n   * Adds a value to the set. If the set already contains the value, nothing happens.\n   * Overrides Set.prototype.add.\n   * @name Set.prototype.add\n   * @function\n   * @throws Error if rules function exists and {value} failed the rules check.\n   * @param value {*}- Required. Any arbitrary value to be added to the set.\n   * @returns {Set} the Set object\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add\n   */\n\n  function add (value) {\n    if (this.rulesFct && !this.rulesFct.call(null, value)) {\n      throw new Error(`Value [${value}] does not match ruleset.`)\n    }\n\n    // in case we add another set, we actually need to (recursively) check\n    // whether the set is already included, since the original add function\n    // only checks for uniqueness on a reference level\n    if (isSet(value) && this.has(value)) {\n      return this\n    }\n\n    return originals.add.call(this, value)\n  }\n\n/**\n * Resolves an element's inner structure to make it comparable by JSON.stringify.\n * @private\n */\nfunction resolve (obj, circ = new originals.constructor([obj])) {\n  if (typeof obj === 'undefined' ||\n    typeof obj === 'string' ||\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    obj === null) {\n    return obj\n  }\n\n  // if we have a set we convert it to an Array and continue treating it as such\n  if (isSet(obj)) {\n    obj = Array.from(obj)\n  }\n\n  if (typeof obj === 'function') {\n    const fctObj = { fctStr: String(obj).replace(/\\s+/g, '') } // function body to string\n    // resolve all function properties / attached references\n    fctObj.refs = Object.getOwnPropertyNames(obj).map(key => originals.has.call(circ, obj[key]) ? 'circular' : resolve(obj[key], circ))\n    return fctObj\n  }\n\n  const isArray = Array.isArray(obj)\n  if (typeof obj !== 'object' && !isArray) {\n    return obj\n  }\n\n  // add obj to check for\n  // circular references\n  circ.add(obj)\n\n  if (isArray) {\n    return obj.map(el => originals.has.call(circ, el) ? 'circular' : resolve(el, circ))\n  }\n\n  const copy = {}\n  Object.getOwnPropertyNames(obj)\n    .sort((a, b) => a.localeCompare(b))\n    .forEach(key => {\n      copy[key] = originals.has.call(circ, obj[key]) ? 'circular' : resolve(obj[key], circ)\n    })\n  return copy\n}\n\n/**\n * Checks if the current set instance contains a given value by recursive deep compare.\n * Overrides the original Set.prototype.has.\n * The check is recursive and respects\n * <ul>\n *   <li>primitive types</li>\n *   <li>complex types, such as Objects or Arrays</li>\n *   <li>nested Objects and cyclic references</li>\n *   <li>functions</li>\n *   <li>functions with properties attached</li>\n *   <li>sets, sets of sets</li>\n * </ul>\n *\n * Note, that functions will be checked against their whitespace-trimmed bodies, which can return false negatives,\n * if for example a comment is added to the compare function that not exists in the original function.\n *\n * @function\n * @name Set.prototype.has\n * @example\n * const a = Set.from({ a:true, b:false })\n * a.has({ b:false, a:true })  // true\n * a.has({ b:false, a:false }) // false\n * @param value {*} - The value to be checked.\n * @returns {boolean} - True, if the value is contained by the set. False, if otherwise.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has\n */\nscope.Set.prototype.has = function has (value) {\n  const valType = typeof value\n  if (valType === 'string' || valType === 'number' || valType === 'boolean') {\n    return originals.has.call(this, value)\n  }\n\n  const iterator = this.values()\n  let element\n  while ((element = iterator.next().value) !== undefined) {\n    const elType = typeof element\n\n    if (elType !== valType) {\n      return false\n    }\n\n    const setCompare = isSet(element) && isSet(value)\n\n    // if both point to the same reference\n    if (element === value) {\n      return true\n    } else\n\n    // if we want to check if this set has a set with the\n    // same elements as the given set in the argument,\n    // we need to check for equality of all elements of this set\n    // and the argument set\n    if (setCompare && element.equal(value)) {\n      return true\n    } else\n\n    // - if we want to check if ordered pairs (represented as arrays),\n    //   are equal, we resolve their children and compare their strings.\n    // - For all nested objects we recursively create a \"sorted\"\n    //   version of both and compare their strings.\n    // - functions are string-ed and their properties are resolved\n    //   like objects\n    if ((elType === 'function' && valType === 'function') ||\n      (!setCompare && elType === 'object' && valType === 'object') ||\n      (Array.isArray(element) && Array.isArray(value))) {\n      const sortedElmnt = resolve(element)\n      const sortedValue = resolve(value)\n\n      if (JSON.stringify(sortedElmnt) === JSON.stringify(sortedValue)) {\n        return true\n      }\n    }\n  }\n\n  // and if nothing has matched, we assume\n  // that it is not contained in this set\n  return false\n}\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// PROTOTYPES                                                                       //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\nscope.Set.prototype.rules =\n  /**\n   * Pass a function that dictates the rules for elements to be part of this set.\n   * Use without args to get the current rules function.\n   * <br>\n   * A rules function needs to fulfill the following requirements:\n   * <ul>\n   *   <li>Obtain a single element as argument</li>\n   *   <li>Check, if that element passes certain conditions</li>\n   *   <li>Return false if the element fails any condition</li>\n   *   <li>Otherwise return true</li>\n   * </ul>\n   * <br>\n   * If a set contains a rules function (or a merge of many rules functions), the element will only be added to the set,\n   * if it passes the rules check.\n   * @function\n   * @name Set.prototype.rules\n   * @example\n   * const isInt = n => Number.isInteger(n)\n   * const integers = Set.from()\n   * integers.rules(isInt)\n   * integers.add(1)   // OK, no error\n   * integers.add(1.5) // throws error!\n   * integers.add(1.0) // OK, because 1.0 === 1 in JS Number\n   * @param value {Function} (Optional) a Function that obtains a single argument and returns either a truthy or falsey value.\n   * @returns {Function|undefined} Returns the current rules Function or undefined if there is on rules function assigned.\n   */\n  function rules (value) {\n    if (value) {\n      checkRules([value])\n      this.rulesFct = value\n    }\n    return this.rulesFct\n  }\n\nscope.Set.prototype.toArray =\n\n  /**\n   * Creates an (unsorted) array from all elements of this set.\n   * @function\n   * @name Set.prototype.toArray\n   * @example new Set([1, 2, 3, 4]).toArray() // [ 1, 2, 3, 4 ]\n   * @returns {Array} Array containing all elements of this set in unsorted order.\n   */\n  function toArray () {\n    const self = this\n    const out = []\n    out.length = self.size\n    let count = 0\n    self.forEach(value => {\n      out[count++] = value\n    })\n    return out\n  }\n\nscope.Set.prototype.any =\n  /**\n   * Returns an arbitrary element of this set.\n   * Basically the first element, retrieved by iterator.next().value will be used.\n   * @function\n   * @name Set.prototype.any\n   * @returns {*} An arbitrary element of the current set that could by of any type, depending on the elements of the set.\n   */\n  function any () {\n    const self = this\n    const iterator = self.values()\n    return iterator.next().value\n  }\n\nscope.Set.prototype.randomElement =\n  /**\n   * Returns a random element of this set.\n   * One element of this set is chosen at random and returned.  The probability distribution is uniform.  Math.random() is used internally for this purpose.\n   * @function\n   * @name Set.prototype.randomElement\n   * @returns {*} An element chosen randomly from the current set that could be of any type, depending on the elements of the set.\n   */\n  function randomElementUnary () {\n    const array = this.toArray()\n    const randomIndex = Math.floor(Math.random() * array.length)\n    return array[randomIndex]\n  }\n\nscope.Set.prototype.isSupersetOf =\n  /**\n   * Checks, whether the current set (this) is a superset of the given set.\n   * A set A is superset of set B, if A contains all elements of B.\n   * <br>\n   * Expression: <code>A ⊇ B</code>\n   * @function\n   * @name Set.prototype.isSupersetOf\n   * @example\n   * const a = Set.from(1,2,3,4)\n   * const b = Set.from(1,2,3)\n   * const c = Set.from(1,2,3,4,5)\n   * a.isSupersetOf(b) // true\n   * a.isSupersetOf(c) // false\n   * c.isSupersetOf(b) // true\n   * @param set {Set} - A set instance of which this set is checked to be the superset.\n   * @throws Throws an error, if the given set is not a set instance.\n   * @returns {boolean} true if this set is the superset of the given set, otherwise false.\n   * @see https://en.wikipedia.org/wiki/Subset\n   */\n  function isSupersetOf (set) {\n    const iterator = set.values()\n    let value\n    while ((value = iterator.next().value) !== undefined) {\n      if (!this.has(value)) return false\n    }\n    return true\n  }\n\nscope.Set.prototype.isSubsetOf =\n  /**\n   * Checks, whether the current set (this) is a subset of the given set.\n   * A set A is subset of set B, if B contains all elements of A.\n   * <br>\n   * Expression: <code>A ⊆ B</code>\n   * <br>\n   * If their sizes are also equal, they can be assumed as equal.\n   * If their sizes are not equal, then A is called a proper subset of B.\n   * @function\n   * @name Set.prototype.isSubsetOf\n   * @example\n   * const a = Set.from(1,2,3,4)\n   * const b = Set.from(1,2,3)\n   * const c = Set.from(1,2,3,4,5)\n   * a.isSubsetOf(b) // false\n   * b.isSubsetOf(c) // true\n   * c.isSubsetOf(a) // false\n   * @param set {Set} - A set instance of which this set is checked to be the subset.\n   * @throws Throws an error, if the given set is not a set instance.\n   * @returns {boolean} - true if this set is the subset of the given set, false otherwise\n   * @see https://en.wikipedia.org/wiki/Subset\n   * @see Set.prototype.equal\n   * @see Set.prototype.isProperSubsetOf\n   */\n  function isSubsetOf (set) {\n    return set.isSupersetOf(this)\n  }\n\nscope.Set.prototype.properSupersetOf =\n  /**\n   * Checks, whether the current set (this) is a proper superset of the given set.\n   * A set A is a proper subset of set B, if A contains all elements of B and their sizes are not equal.\n   * <br>\n   * Expression: <code>A ⊃ B</code>\n   * @function\n   * @name Set.prototype.properSupersetOf\n   * @param set {Set} - A set instance of which this set is checked to be the proper superset.\n   * @returns {boolean}\n   * @see https://en.wikipedia.org/wiki/Subset\n   */\n  function isProperSupersetOf (set) {\n    return this.size !== set.size && this.isSupersetOf(set)\n  }\n\nscope.Set.prototype.properSubsetOf =\n  /**\n   * Checks, whether the current set (this) is a proper subset of the given set.\n   * A set A is a proper subset of set B, if B contains all elements of A and their sizes are not equal.\n   * <br>\n   * Expression: <code>A ⊂ B</code>\n   * @function\n   * @name Set.prototype.properSupersetOf\n   * @param set {Set} - A set instance of which this set is checked to be the proper subset.\n   * @returns {boolean}\n   * @see https://en.wikipedia.org/wiki/Subset\n   */\n  function isProperSubsetOf (set) {\n    return this.size !== set.size && this.isSubsetOf(set)\n  }\n\nscope.Set.prototype.equal =\n  /**\n   * Checks, whether two sets are equal in terms of their contained elements.\n   * Note: This implementation uses a deep object comparison in order to check for \"sameness\".\n   * This allows also to check equality for more complex / nested structures without the restriction of interpreting\n   * \"sameness\" as \"being the exact same instance\". If such an equality is desired, please use Set.prototype.equalSrict\n   * @function\n   * @name Set.prototype.equal\n   * @example\n   * const a = Set.from(1,2,3)\n   * const b = Set.from(1,2,3.0) // note that 3.0 will evaluate to 3 here!\n   * a === b    // false\n   * a.equal(b) // true\n   * @example\n   * const a = Set.from({ a:true, b:false })\n   * const b = Set.from({ b:false, a:true })\n   * a.equal(b) // true\n   * @param set {Set} - A set instance, which this set is to be compared with.\n   * @throws Throws an error if the given paramter is not a Set instance.\n   * @returns {boolean} true, if all elements of this set equal to the elements of the given set.\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness\n   * @see Set.prototype.isSubsetOf\n   */\n  function equal (set) {\n    checkSet(set)\n    if (this.size !== set.size) {\n      return false\n    }\n    return this.isSubsetOf(set)\n  }\n\nscope.Set.prototype.isEmpty =\n  /**\n   * Checks whether this set is the empty set.\n   * A Set is empty if and only if it has no elements.  This is the same thing as having size (cardinality) 0.  The empty set is often denoted ∅ or {}.\n   * @example\n   * const A = new Set()\n   * const B = new Set([])\n   * const C = Set.from()\n   * const D = Set.from(7)\n   * A.isEmpty() // true\n   * B.isEmpty() // true\n   * C.isEmpty() // true\n   * D.isEmpty() // false\n   * @function\n   * @name Set.prototype.isEmpty\n   * @throws Throws an error if any arguments are given.\n   * @returns {boolean}\n   * @see https://en.wikipedia.org/wiki/Empty_set\n   */\n  function isEmptyUnary () {\n    return this.size === 0\n  }\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// CONSTRUCTOR                                                                      //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\nscope.Set =\n\n  /**\n   * Use <code>new Set(elements, rulesFct)</code> to create new sets. Alternatively you can use <code>Set.from</code>\n   * @class\n   * @name Set\n   * @classdesc Extended version of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">Set (MDN link)</a>\n   * @param elements {array} - an Array of element.\n   * @param rulesFct {function} - a function which every element added to the set needs to pass.\n   * @see Set.from\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n   * @returns {Set} An instance of the extended version of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">Set (MDN link)</a>\n   */\n  function Set (elements, rulesFct) {\n    const original = new originals.constructor()\n    if (rulesFct) {\n      original.rules(rulesFct)\n    }\n    if (elements) { elements.forEach(element => original.add(element)) }\n    return original\n  }\n\n/**\n * The prototype is the original Set constructor\n * @type {contains}\n */\nscope.Set.prototype = originals.constructor.prototype\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// STATICS                                                                          //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\nscope.Set.from =\n\n  /**\n   * Creates a new Set from arbitrary arguments without the need of \"new\" and the array notation.\n   * @function\n   * @name Set.from\n   * @example Set.from(1,2,3,4,5) // returns Set { 1, 2, 3, 4, 5 }\n   * @example\n   * const ints = Set.from(1,2,3)\n   * const flts = Set.from(4.5, 5.6, 6.7)\n   * Set.from(ints, flts) // returns Set { Set {1, 2, 3}, Set { 4.5, 5.6, 6.7 } }\n   * @param args {...*} - values of any types / length (using comma notation or spread operator)\n   * @returns {Set} A set containing the given argument values.\n   */\n  function from (...args) {\n    return new Set([...args])\n  }\n\nscope.Set.toSet =\n  /**\n   * Autowraps a value to a Set, unless it is already a Set.\n   * @function\n   * @name Set.toSet\n   * @param value  {*} - Any arbitrary value\n   * @returns {Set} A Set containing the value or the value if it is already a Set.\n   */\n  function toSet (value) {\n    return value instanceof Set ? value : Set.from(value)\n  }\n\nscope.Set.copy =\n  /**\n   * Copies all elements of a given Set instance into a new Set and returns it.\n   * <strong>It does not deep-clone the elements of the set.</strong>\n   * @function\n   * @name Set.copy\n   * @throws Throws an error if the argument is not a Set instance.\n   * @param set {Set} a set instance from which to copy from\n   * @returns {Set} a new Set instance containing all elements of the source.\n   */\n  function copy (set) {\n    checkSet(set)\n    const c = new Set()\n    set.forEach(el => c.add(el))\n    return c\n  }\n\nscope.Set.union =\n  /**\n   * Creates the set union of an arbitrary number of sets.\n   * The union S of any number of sets M<sub>i</sub> is the set that consists of all elements of each M<sub>i</sub>.\n   * <br>Expression: <code>∪ M = S</code>\n   * <br>Example: <code>∪ {M_1, M_2, M_3} = S</code>\n   * <br>Example: <code>∪ {A, B, C} = S</code>\n   * <br>Example: <code>∪ {{0,4}, {1}, {9}} = {0,1,4,9}</code>\n   * @example\n   * const A = Set.from(0, 4)\n   * const B = Set.from(1)\n   * const C = Set.from(9)\n   * Set.union(A, B, C) // Set { 0, 1, 4, 9 }\n   * const M = [A, B, C]\n   * Set.union(...M) // Set { 0, 1, 4, 9 }\n   * @name Set.union\n   * @function\n   * @param args {...Set} - an arbitrary list of Set instances\n   * @throws Throws an error if any of the arguments is not a Set instance.\n   * @returns {Set} a Set instance with the unified elements of the given args.\n   * @see https://en.wikipedia.org/wiki/Union_(set_theory)#Arbitrary_unions\n   */\n  function unionArbitrary (...args) {\n    checkSets(args)\n    const set3 = new Set()\n    args.forEach(set => set.forEach(value => set3.add(value)))\n    return set3\n  }\n\n/**\n * Creates the set union of two sets.\n * The union of A and B is the set C that consists of all elements of A and B.\n * <br>Expression: <code>A ∪ B = C</code>\n * <br>Example: <code>{1,2} ∪ {1,7,8,9} = {1,2,7,8,9}</code>\n * @example\n * const A = Set.from(1, 2)\n * const B = Set.from(1, 7, 8, 9)\n * A.union(B) // Set { 1, 2, 7, 8, 9 }\n * @name Set.prototype.union\n * @function\n * @param args {set} - the other set to union with.\n * @throws Throws an error if there is not exactly one argument.\n * @throws Throws an error if the argument is not a Set instance.\n * @returns {Set} a Set instance with the unified elements of the given args.\n * @see https://en.wikipedia.org/wiki/Union_(set_theory)#Union_of_two_sets\n */\nscope.Set.prototype.union = arbitraryToBinary(scope.Set.union)\n\nscope.Set.intersection =\n  /**\n   * Creates the set intersection of an arbitrary number of sets.\n   * The intersection S of any number of sets M<sub>i</sub> is the set whose elements consist of the elements that occur in every single set M<sub>i</sub>.\n   * <br>Expression: <code>∩ M = S</code>\n   * <br>Example: <code>∩ {M_1, M_2, M_3} = S</code>\n   * <br>Example: <code>∩ {A, B, C} = S</code>\n   * <br>Example: <code>∩ {{0,1,2,4}, {1,2,9}, {0,1,2}} = {1,2}</code>\n   * @example\n   * const A = Set.from(0, 1, 2, 4)\n   * const B = Set.from(1, 2, 9)\n   * const C = Set.from(0, 1, 2)\n   * Set.intersection(A, B, C) // Set { 1, 2 }\n   * const M = [A, B, C]\n   * Set.intersection(...M) // Set { 1, 2 }\n   * @name Set.intersection\n   * @function\n   * @param args {...Set}- an arbitrary list of Set instances\n   * @throws Throws an error if any of the arguments is not a Set instance.\n   * @returns {Set} a Set instance with the shared elements of the given args.\n   * @see https://en.wikipedia.org/wiki/Intersection_(set_theory)#Arbitrary_intersections\n   */\n  function intersectionArbitrary (...args) {\n    checkSets(args)\n    if (!args || args.length === 0) {\n      throw new Error('The intersection operator currently does not support 0 arguments.')\n    }\n    const set3 = new Set()\n\n    const minimumSet = args.reduce((prev, curr) => {\n      return (prev.size < curr.size) ? prev : curr\n    }, args[0])\n\n    for (const value of minimumSet) {\n      if (args.every(compare => compare.has(value))) {\n        set3.add(value)\n      }\n    }\n    return set3\n  }\n\n/**\n * Creates the set intersection of two sets.\n * The intersection S of sets A and B is the set whose elements consist of the elements that occur in both A and B.\n * <br>Expression: <code>A ∩ B = S</code>\n * <br>Example: <code>{0,1,2,4} ∩ {1,2,9} = {1,2}</code>\n * @example\n * const A = Set.from(0, 1, 2, 4)\n * const B = Set.from(1, 2, 9)\n * A.intersect(B) // Set { 1, 2 }\n * @name Set.prototype.intersect\n * @function\n * @param args {set} - the other set to intersect with.\n * @throws Throws an error if there is not exactly one argument.\n * @throws Throws an error if the argument is not a Set instance.\n * @returns {Set} a Set instance with the shared elements of this set and the other set.\n * @see https://en.wikipedia.org/wiki/Intersection_(set_theory)#Definition\n */\nscope.Set.prototype.intersect = arbitraryToBinary(scope.Set.intersection)\n\nscope.Set.difference =\n  /**\n   * Computes the set difference of two sets (subtracts B from A): <code>C = A \\ B</code>.  This is also known as the \"relative complement\".\n   *\n   * @name Set.difference\n   * @function\n   * @throws Throws an error if any of the arguments is not a Set instance.\n   * @param set1 - A the set to be subtracted from\n   * @param set2 - B the set whose elements will be subtracted from A\n   * @returns {Set|*} A new Set with all elements of A minus the elements of B\n   */\n  function difference (set1, set2) {\n    checkSet(set1)\n    checkSet(set2)\n    const set3 = new Set([])\n    set1.forEach(value => {\n      if (!set2.has(value)) {\n        set3.add(value)\n      }\n    })\n    return set3\n  }\n\nscope.Set.complement =\n\n  /**\n   * Computes the complement of set B where U is the universe: <code>C = U \\ B</code>.  This is also known as the \"absolute complement\".\n   *\n   * @name Set.complement\n   * @function\n   * @throws Throws an error if any of the arguments is not a Set instance.\n   * @throws Throws an error if any element in B does not occur in U.\n   * @param set1 - U the set to be subtracted from\n   * @param set2 - B the set whose elements will be subtracted from A\n   * @returns {Set|*} A new Set with all elements of U minus the elements of B\n   */\n  function complement (set1, set2) {\n    checkSet(set1)\n    checkSet(set2)\n    if (!set1.isSupersetOf(set2)) {\n      throw new Error('[set2] has an element which is not in the universe [set1].')\n    }\n    return Set.difference(set1, set2)\n  }\n\n/**\n *\n * @private\n */\nfunction symDiff (set1, set2) {\n  const set3 = new Set()\n\n  function addToSet (source, compare, target) {\n    source.forEach(value => {\n      if (!compare.has(value)) {\n        target.add(value)\n      }\n    })\n  }\n\n  addToSet(set1, set2, set3)\n  addToSet(set2, set1, set3)\n  return set3\n}\n\nscope.Set.symDiff =\n\n  /**\n   * Creates the symmetric difference (disjunctive union) of an arbitrary number (2 .. n) of sets.\n   * The symmetric difference of two sets A and B is a set, that contains only those elements,\n   * which are in either of the sets and not in their intersection.\n   * The symmetric difference is commutative and associative, which is why arbitrary number of sets can be used as input\n   * for a sequencial-computed symmetric difference.\n   * <br>\n   * Expression: <code>C = A Δ B</code>\n   *\n   * @function\n   * @name Set.symDiff\n   * @param args {...Set}- An arbitrary amount of Set instances\n   * @example\n   * const a = Set.from(1,2,3)\n   * const b = Set.from(3,4)\n   * Set.symDiff(a, b) // Set { 1, 2, 4 }\n   * @throws Throws an error if any of the given arguments is not a set instance.\n   * @returns {Set} Returns a new Set, that contains only elements.\n   * @see https://en.wikipedia.org/wiki/Symmetric_difference\n   */\n  function symmetricDifference (...args) {\n    args.forEach(arg => checkSet(arg))\n\n    if (args.length === 2) {\n      return symDiff(...args)\n    }\n\n    let set3 = symDiff(args.shift(), args.shift())\n    while (args.length > 0) {\n      set3 = symDiff(set3, args.shift())\n    }\n    return set3\n  }\n\nscope.Set.cartesian =\n\n  /**\n   * Creates the cartesian product of two given sets.\n   * The cartesian product of two sets A and B is the set of all ordered pairs (a, b) where a ∈ A and b ∈ B.\n   * <br>\n   * Expression: <code>C = A x B = { (a, b) | a ∈ A and b ∈ B}</code>\n   * <br>\n   * Note, that <code>A x B ≠ B x A</code> (not commutative)\n   * @function\n   * @name Set.cartesian\n   * @param set1 {Set} - A set instance\n   * @param set2 {Set} - A set instance\n   * @example\n   * const a = Set.from(1,2)\n   * const b = Set.from(3,4)\n   * Set.cartesian(a, b) // Set { [1, 3], [1, 4], [2, 3], [2, 4] }\n   * Set.cartesian(b, a) // Set { [3, 1], [3, 2], [4, 1], [4, 2] }\n   * @throws Throws an error unless both arguments are set instances.\n   * @return {Set} a new set instance, that contains the ordered element pairs.\n   * @see https://en.wikipedia.org/wiki/Cartesian_product\n   */\n\n  function cartesianProduct (set1, set2) {\n    checkSet(set1)\n    checkSet(set2)\n    const set3 = new Set()\n    set1.forEach(value1 => set2.forEach(value2 => set3.add([value1, value2])))\n    return set3\n  }\n\n/**\n * https://en.wikipedia.org/wiki/Power_set\n * @private\n */\nfunction subsets (S, output = new Set()) {\n  checkSet(S)\n  if (S.size === 0) {\n    return Set.from(S)\n  }\n\n  const it = S.values()\n\n  let result = it.next()\n  while (!result.done) {\n    const e = result.value\n    const eSet = Set.from(e)\n\n    // get difference between first element and the rest\n    const diff = Set.difference(S, eSet)\n    output.add(diff)\n\n    // recursion: get subsets for the difference, too\n    const subs = subsets(diff)\n    subs.forEach(entry => output.add(entry))\n\n    result = it.next()\n  }\n  return output\n}\n\nscope.Set.power =\n\n  /**\n   * Creates the powerset of a given set instance by using a recursive algorithm (see <a href=\"https://en.wikipedia.org/wiki/Power_set\">Wikipedia</a>, section Algorithms).\n   * The powerset of a set contains all possible subsets of the set, plus itself and the empty set.\n   * <br>\n   * <strong>Attention:</strong> This method grows exponentially with the size of the given set.\n   * @name Set.power\n   * @function\n   * @param set {Set} - A Set instance.\n   * @throws\n   * Throws an error if the given set is not a set instance.\n   * @returns {Set} a new set instance with all subsets of the given set, plus the given set itself and the empty set.\n   * @see https://en.wikipedia.org/wiki/Power_set\n   */\n  function powerSet (set) {\n    checkSet(set)\n\n    const subs = subsets(set)\n    subs.add(new Set())\n    subs.add(set)\n    set.forEach(value => subs.add(Set.from(value)))\n    return subs\n  }\n\n/** @private **/\nconst mergeRulesAny = (strict, rules) => {\n  const targetFn = strict\n    ? rules.every\n    : rules.some\n\n  return value => {\n    const passed = targetFn.call(rules, rule => rule.call(value))\n    if (!passed) {\n      throw new Error(`Value [${value}] does not match any rule of the ruleset.`)\n    }\n    return true\n  }\n}\n\nscope.Set.mergeRules =\n  /**\n   * Merges two rules functions with a strict pass concept.\n   * The resulting function requires the given element to pass at least one of the given functions (logical OR).\n   * @function\n   * @name Set.mergeRules\n   * @throws Throws an error if any of the given parameters is not a Function\n   * @param rules {...Function} - An arbitrary amount of (rules-) functions. See {@link Set.prototype.rules} for requirements of a rules function.\n   * @returns {function(*=): boolean} The resulting rules function that can be attached to a set instance.\n   * @see Set.prototype.rules\n   *\n   */\n  function mergeRules (...rules) {\n    checkRules(rules)\n    return mergeRulesAny(false, rules)\n  }\n\nscope.Set.mergeRulesStrict =\n  /**\n   * Merges two rules functions with a strict pass concept.\n   * The resulting function requires the given element to pass all of the given functions (logical AND).\n   * Thus, if the element fails one, it fails all.\n   * <strong>Attention:</strong> If passed rules are mutually exclusive, none given element will pass the test in any circumstance.\n   * @function\n   * @name Set.mergeRulesStrict\n   * @throws Throws an error if any of the given parameters is not a Function\n   * @param rules {...Function} - An arbitrary amount of (rules-) functions. See {@link Set.prototype.rules} for requirements of a rules function.\n   * @returns {function(*=): boolean} The resulting rules function that can be attached to a set instance.\n   * @see Set.prototype.rules\n   */\n  function mergeRulesStrict (...rules) {\n    checkRules(rules)\n    return mergeRulesAny(true, rules)\n  }\n\n/**\n * Flag to indicate the presence of this polyfill\n * @type {boolean}\n * @private\n */\nscope.Set.__isExtended__ = true\n"],"file":"index.js"}