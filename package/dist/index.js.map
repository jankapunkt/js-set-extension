{"version":3,"sources":["../lib/index.js"],"names":["checkRules","rules","forEach","rule","Error","value","checkSet","set","constructor","global","Set","checkSets","sets","checkArgsSingle","args","length","arbitraryToBinary","arbitraryFunc","binaryFunc","isSet","s","Object","prototype","toString","call","_originalAdd","add","rulesFct","has","originalHas","resolve","obj","circ","_originalSet","Array","from","fctObj","fctStr","String","replace","refs","getOwnPropertyNames","map","key","isArray","el","copy","sort","a","b","localeCompare","valType","iterator","values","element","next","elType","setCompare","equal","sortedElmnt","sortedValue","JSON","stringify","toArray","self","out","size","count","any","randomElementUnary","array","randomIndex","Math","floor","random","randomElement","isSupersetOf","isSubsetOf","isProperSupersetOf","properSupersetOf","isProperSubsetOf","properSubsetOf","isEmptyUnary","isEmpty","elements","original","toSet","c","unionArbitrary","set3","union","intersectionArbitrary","minimumSet","reduce","prev","curr","every","compare","intersection","intersect","difference","set1","set2","complement","symDiff","addToSet","source","target","symmetricDifference","arg","shift","cartesian","cartesianProduct","value1","value2","addToSubset","e","T","X","subsets","S","output","it","result","done","eSet","diff","subs","entry","powerSet","power","mergeRules","passed","some","mergeRulesStrict","__isExtended__"],"mappings":"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","sourcesContent":["// //////////////////////////////////////////////////////////////////////////////// //\n// MIT License\n//\n// Copyright (c) 2018 Jan Küster\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n//   The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n//   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n//   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n//   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n// //////////////////////////////////////////////////////////////////////////////// //\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// INTERNAL                                                                         //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * @private\n */\nfunction checkRules (rules) {\n  rules.forEach(rule => {\n    if (typeof rule !== 'function') {\n      throw new Error(`Expected [rule] to be typeof [function], got [${typeof value}]`)\n    }\n  })\n  return true\n}\n\n/**\n * @private\n */\nfunction checkSet (set) {\n  if (!set || !set.constructor || !(set instanceof global.Set)) {\n    throw new Error(`Expected [set] to be instanceof [Set], got [${set && set.constructor}]`)\n  }\n  return true\n}\n\n/**\n * @private\n */\nfunction checkSets (sets) {\n  sets.forEach(set => checkSet(set))\n  return true\n}\n\n/**\n * @private\n */\nfunction checkArgsSingle (args) {\n  if (!args || args.length !== 1) {\n    throw new Error(`The function must be given exactly 1 argument.`)\n  }\n  return true\n}\n\n/**\n * A decorator which, given an arbitrary set function, produces the corresponding binary operation.\n * @private\n */\nfunction arbitraryToBinary (arbitraryFunc) {\n  return function binaryFunc (...args) {\n    checkArgsSingle(args)\n    const set = args[0]\n    return arbitraryFunc(this, set)\n  }\n}\n\n/**\n * @private checks, whether an Object is a Set\n */\nconst isSet = s => Object.prototype.toString.call(s) === '[object Set]'\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// OVERRIDES                                                                        //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * The original add function.\n * @private\n */\nconst _originalAdd = global.Set.prototype.add\n\n/**\n * Adds a value to the set. If the set already contains the value, nothing happens.\n * Overrides Set.prototype.add.\n * @name Set.prototype.add\n * @function\n * @throws Error if rules function exists and {value} failed the rules check.\n * @param value {*}- Required. Any arbitrary value to be added to the set.\n * @returns {Set} the Set object\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/add\n */\nfunction add (value) {\n  if (this.rulesFct && !this.rulesFct.call(null, value)) {\n    throw new Error(`Value [${value}] does not match ruleset.`)\n  }\n\n  // in case we add another set, we actually need to (recursively) check\n  // whether the set is already included, since the original add function\n  // only checks for uniqueness on a reference level\n  if (isSet(value) && this.has(value)) {\n    return this\n  }\n\n  return _originalAdd.call(this, value)\n}\n\nglobal.Set.prototype.add = add\n\n/**\n * The original has function reference.\n * @private\n */\nconst originalHas = global.Set.prototype.has\n\n/**\n * Resolves an element's inner structure to make it comparable by JSON.stringify.\n * @private\n */\nfunction resolve (obj, circ = new _originalSet([obj])) {\n  if (typeof obj === 'undefined' ||\n    typeof obj === 'string' ||\n    typeof obj === 'number' ||\n    typeof obj === 'boolean' ||\n    obj === null) {\n    return obj\n  }\n\n  // if we have a set we convert it to an Array and continue treating it as such\n  if (isSet(obj)) {\n    obj = Array.from(obj)\n  }\n\n  if (typeof obj === 'function') {\n    const fctObj = { fctStr: String(obj).replace(/\\s+/g, '') } // function body to string\n    // resolve all function properties / attached references\n    fctObj.refs = Object.getOwnPropertyNames(obj).map(key => originalHas.call(circ, obj[key]) ? 'circular' : resolve(obj[key], circ))\n    return fctObj\n  }\n\n  const isArray = Array.isArray(obj)\n  if (typeof obj !== 'object' && !isArray) {\n    return obj\n  }\n\n  // add obj to check for\n  // circular references\n  circ.add(obj)\n\n  if (isArray) {\n    return obj.map(el => originalHas.call(circ, el) ? 'circular' : resolve(el, circ))\n  }\n\n  const copy = {}\n  Object.getOwnPropertyNames(obj)\n    .sort((a, b) => a.localeCompare(b))\n    .forEach(key => {\n      copy[key] = originalHas.call(circ, obj[key]) ? 'circular' : resolve(obj[key], circ)\n    })\n  return copy\n}\n\n/**\n * Checks if the current set instance contains a given value by recursive deep compare.\n * Overrides the original Set.prototype.has.\n * The check is recursive and respects\n * <ul>\n *   <li>primitive types</li>\n *   <li>complex types, such as Objects or Arrays</li>\n *   <li>nested Objects and cyclic references</li>\n *   <li>functions</li>\n *   <li>functions with properties attached</li>\n *   <li>sets, sets of sets</li>\n * </ul>\n *\n * Note, that functions will be checked against their whitespace-trimmed bodies, which can return false negatives,\n * if for example a comment is added to the compare function that not exists in the original function.\n *\n * @function\n * @name Set.prototype.has\n * @example\n * const a = Set.from({ a:true, b:false })\n * a.has({ b:false, a:true })  // true\n * a.has({ b:false, a:false }) // false\n * @param value {*} - The value to be checked.\n * @returns {boolean} - True, if the value is contained by the set. False, if otherwise.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/has\n */\nglobal.Set.prototype.has = function has (value) {\n  const valType = typeof value\n  if (valType === 'string' || valType === 'number' || valType === 'boolean') {\n    return originalHas.call(this, value)\n  }\n\n  const iterator = this.values()\n  let element\n  while ((element = iterator.next().value) !== void 0) {\n    const elType = typeof element\n\n    if (elType !== valType) {\n      return false\n    }\n\n    const setCompare = isSet(element) && isSet(value)\n\n    // if both point to the same reference\n    if (element === value) {\n      return true\n    } else\n\n    // if we want to check if this set has a set with the\n    // same elements as the given set in the argument,\n    // we need to check for equality of all elements of this set\n    // and the argument set\n    if (setCompare && element.equal(value)) {\n      return true\n    } else\n\n    // - if we want to check if ordered pairs (represented as arrays),\n    //   are equal, we resolve their children and compare their strings.\n    // - For all nested objects we recursively create a \"sorted\"\n    //   version of both and compare their strings.\n    // - functions are string-ed and their properties are resolved\n    //   like objects\n    if ((elType === 'function' && valType === 'function') ||\n      (!setCompare && elType === 'object' && valType === 'object') ||\n      (Array.isArray(element) && Array.isArray(value))) {\n      const sortedElmnt = resolve(element)\n      const sortedValue = resolve(value)\n\n      if (JSON.stringify(sortedElmnt) === JSON.stringify(sortedValue)) {\n        return true\n      }\n    }\n  }\n\n  // and if nothing has matched, we assume\n  // that it is not contained in this set\n  return false\n}\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// PROTOTYPES                                                                       //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * Pass a function that dictates the rules for elements to be part of this set.\n * Use without args to get the current rules function.\n * <br>\n * A rules function needs to fulfill the following requirements:\n * <ul>\n *   <li>Obtain a single element as argument</li>\n *   <li>Check, if that element passes certain conditions</li>\n *   <li>Return false if the element fails any condition</li>\n *   <li>Otherwise return true</li>\n * </ul>\n * <br>\n * If a set contains a rules function (or a merge of many rules functions), the element will only be added to the set,\n * if it passes the rules check.\n * @function\n * @name Set.prototype.rules\n * @example\n * const isInt = n => Number.isInteger(n)\n * const integers = Set.from()\n * integers.rules(isInt)\n * integers.add(1)   // OK, no error\n * integers.add(1.5) // throws error!\n * integers.add(1.0) // OK, because 1.0 === 1 in JS Number\n * @param value {Function} (Optional) a Function that obtains a single argument and returns either a truthy or falsey value.\n * @returns {Function|undefined} Returns the current rules Function or undefined if there is on rules function assigned.\n */\nfunction rules (value) {\n  if (value) {\n    checkRules([value])\n    this.rulesFct = value\n  }\n  return this.rulesFct\n}\n\nglobal.Set.prototype.rules = rules\n\n/**\n * Creates an (unsorted) array from all elements of this set.\n * @function\n * @name Set.prototype.toArray\n * @example new Set([1, 2, 3, 4]).toArray() // [ 1, 2, 3, 4 ]\n * @returns {Array} Array containing all elements of this set in unsorted order.\n */\nfunction toArray () {\n  const self = this\n  const out = []\n  out.length = self.size\n  let count = 0\n  self.forEach(value => {\n    out[count++] = value\n  })\n  return out\n}\n\nglobal.Set.prototype.toArray = toArray\n\n/**\n * Returns an arbitrary element of this set.\n * Basically the first element, retrieved by iterator.next().value will be used.\n * @function\n * @name Set.prototype.any\n * @returns {*} An arbitrary element of the current set that could by of any type, depending on the elements of the set.\n */\nfunction any () {\n  const self = this\n  const iterator = self.values()\n  return iterator.next().value\n}\n\nglobal.Set.prototype.any = any\n\n/**\n * Returns a random element of this set.\n * One element of this set is chosen at random and returned.  The probability distribution is uniform.  Math.random() is used internally for this purpose.\n * @function\n * @name Set.prototype.randomElement\n * @returns {*} An element chosen randomly from the current set that could be of any type, depending on the elements of the set.\n */\nfunction randomElementUnary () {\n  const array = this.toArray()\n  const randomIndex = Math.floor(Math.random() * array.length)\n  return array[randomIndex]\n}\n\nglobal.Set.prototype.randomElement = randomElementUnary\n\n/**\n * Checks, whether the current set (this) is a superset of the given set.\n * A set A is superset of set B, if A contains all elements of B.\n * <br>\n * Expression: <code>A ⊇ B</code>\n * @function\n * @name Set.prototype.isSupersetOf\n * @example\n * const a = Set.from(1,2,3,4)\n * const b = Set.from(1,2,3)\n * const c = Set.from(1,2,3,4,5)\n * a.isSupersetOf(b) // true\n * a.isSupersetOf(c) // false\n * c.isSupersetOf(b) // true\n * @param set {Set} - A set instance of which this set is checked to be the superset.\n * @throws Throws an error, if the given set is not a set instance.\n * @returns {boolean} true if this set is the superset of the given set, otherwise false.\n * @see https://en.wikipedia.org/wiki/Subset\n */\nfunction isSupersetOf (set) {\n  const iterator = set.values()\n  let value\n  while ((value = iterator.next().value) !== void 0) {\n    if (!this.has(value)) return false\n  }\n  return true\n}\n\nglobal.Set.prototype.isSupersetOf = isSupersetOf\n\n/**\n * Checks, whether the current set (this) is a subset of the given set.\n * A set A is subset of set B, if B contains all elements of A.\n * <br>\n * Expression: <code>A ⊆ B</code>\n * <br>\n * If their sizes are also equal, they can be assumed as equal.\n * If their sizes are not equal, then A is called a proper subset of B.\n * @function\n * @name Set.prototype.isSubsetOf\n * @example\n * const a = Set.from(1,2,3,4)\n * const b = Set.from(1,2,3)\n * const c = Set.from(1,2,3,4,5)\n * a.isSubsetOf(b) // false\n * b.isSubsetOf(c) // true\n * c.isSubsetOf(a) // false\n * @param set {Set} - A set instance of which this set is checked to be the subset.\n * @throws Throws an error, if the given set is not a set instance.\n * @returns {boolean} - true if this set is the subset of the given set, false otherwise\n * @see https://en.wikipedia.org/wiki/Subset\n * @see Set.prototype.equal\n * @see Set.prototype.isProperSubsetOf\n */\nfunction isSubsetOf (set) {\n  return set.isSupersetOf(this)\n}\n\nglobal.Set.prototype.isSubsetOf = isSubsetOf\n\n/**\n * Checks, whether the current set (this) is a proper superset of the given set.\n * A set A is a proper subset of set B, if A contains all elements of B and their sizes are not equal.\n * <br>\n * Expression: <code>A ⊃ B</code>\n * @function\n * @name Set.prototype.properSupersetOf\n * @param set {Set} - A set instance of which this set is checked to be the proper superset.\n * @returns {boolean}\n * @see https://en.wikipedia.org/wiki/Subset\n */\nfunction isProperSupersetOf (set) {\n  return this.size !== set.size && this.isSupersetOf(set)\n}\n\nglobal.Set.prototype.properSupersetOf = isProperSupersetOf\n\n/**\n * Checks, whether the current set (this) is a proper subset of the given set.\n * A set A is a proper subset of set B, if B contains all elements of A and their sizes are not equal.\n * <br>\n * Expression: <code>A ⊂ B</code>\n * @function\n * @name Set.prototype.properSupersetOf\n * @param set {Set} - A set instance of which this set is checked to be the proper subset.\n * @returns {boolean}\n * @see https://en.wikipedia.org/wiki/Subset\n */\nfunction isProperSubsetOf (set) {\n  return this.size !== set.size && this.isSubsetOf(set)\n}\n\nglobal.Set.prototype.properSubsetOf = isProperSubsetOf\n\n/**\n * Checks, whether two sets are equal in terms of their contained elements.\n * Note: This implementation uses a deep object comparison in order to check for \"sameness\".\n * This allows also to check equality for more complex / nested structures without the restriction of interpreting\n * \"sameness\" as \"being the exact same instance\". If such an equality is desired, please use Set.prototype.equalSrict\n * @function\n * @name Set.prototype.equal\n * @example\n * const a = Set.from(1,2,3)\n * const b = Set.from(1,2,3.0) // note that 3.0 will evaluate to 3 here!\n * a === b    // false\n * a.equal(b) // true\n * @example\n * const a = Set.from({ a:true, b:false })\n * const b = Set.from({ b:false, a:true })\n * a.equal(b) // true\n * @param set {Set} - A set instance, which this set is to be compared with.\n * @throws Throws an error if the given paramter is not a Set instance.\n * @returns {boolean} true, if all elements of this set equal to the elements of the given set.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness\n * @see Set.prototype.isSubsetOf\n */\nfunction equal (set) {\n  checkSet(set)\n  if (this.size !== set.size) {\n    return false\n  }\n  return this.isSubsetOf(set)\n}\n\nglobal.Set.prototype.equal = equal\n\n/**\n * Checks whether this set is the empty set.\n * A Set is empty if and only if it has no elements.  This is the same thing as having size (cardinality) 0.  The empty set is often denoted ∅ or {}.\n * @example\n * const A = new Set()\n * const B = new Set([])\n * const C = Set.from()\n * const D = Set.from(7)\n * A.isEmpty() // true\n * B.isEmpty() // true\n * C.isEmpty() // true\n * D.isEmpty() // false\n * @function\n * @name Set.prototype.isEmpty\n * @throws Throws an error if any arguments are given.\n * @returns {boolean}\n * @see https://en.wikipedia.org/wiki/Empty_set\n */\nfunction isEmptyUnary () {\n  return this.size === 0\n}\n\nglobal.Set.prototype.isEmpty = isEmptyUnary\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// CONSTRUCTOR                                                                      //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * The original Set reference.\n * @private\n */\nconst _originalSet = global.Set\n\n/**\n * Use <code>new Set(elements, rulesFct)</code> to create new sets. Alternatively you can use <code>Set.from</code>\n * @class\n * @name Set\n * @classdesc Extended version of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">Set (MDN link)</a>\n * @param elements {array} - an Array of element.\n * @param rulesFct {function} - a function which every element added to the set needs to pass.\n * @see Set.from\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n * @returns {Set} An instance of the extended version of <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">Set (MDN link)</a>\n */\nfunction Set (elements, rulesFct) {\n  const original = new _originalSet()\n  if (rulesFct) {\n    original.rules(rulesFct)\n  }\n  if (elements) { elements.forEach(element => original.add(element)) }\n  return original\n}\n\nglobal.Set = Set\nglobal.Set.prototype = _originalSet.prototype\n\n// //////////////////////////////////////////////////////////////////////////////// //\n//                                                                                  //\n// STATICS                                                                          //\n//                                                                                  //\n// //////////////////////////////////////////////////////////////////////////////// //\n\n/**\n * Creates a new Set from arbitrary arguments without the need of \"new\" and the array notation.\n * @function\n * @name Set.from\n * @example Set.from(1,2,3,4,5) // returns Set { 1, 2, 3, 4, 5 }\n * @example\n * const ints = Set.from(1,2,3)\n * const flts = Set.from(4.5, 5.6, 6.7)\n * Set.from(ints, flts) // returns Set { Set {1, 2, 3}, Set { 4.5, 5.6, 6.7 } }\n * @param args {...*} - values of any types / length (using comma notation or spread operator)\n * @returns {Set} A set containing the given argument values.\n */\nfunction from (...args) {\n  return new Set([...args])\n}\n\nglobal.Set.from = from\n\n/**\n * Autowraps a value to a Set, unless it is already a Set.\n * @function\n * @name Set.toSet\n * @param value  {*} - Any arbitrary value\n * @returns {Set} A Set containing the value or the value if it is already a Set.\n */\nfunction toSet (value) {\n  return value instanceof Set ? value : Set.from(value)\n}\n\nglobal.Set.toSet = toSet\n\n/**\n * Copies all elements of a given Set instance into a new Set and returns it.\n * <strong>It does not deep-clone the elements of the set.</strong>\n * @function\n * @name Set.copy\n * @throws Throws an error if the argument is not a Set instance.\n * @param set {Set} a set instance from which to copy from\n * @returns {Set} a new Set instance containing all elements of the source.\n */\nfunction copy (set) {\n  checkSet(set)\n  const c = new Set()\n  set.forEach(el => c.add(el))\n  return c\n}\n\nglobal.Set.copy = copy\n\n/**\n * Creates the set union of an arbitrary number of sets.\n * The union S of any number of sets M<sub>i</sub> is the set that consists of all elements of each M<sub>i</sub>.\n * <br>Expression: <code>∪ M = S</code>\n * <br>Example: <code>∪ {M_1, M_2, M_3} = S</code>\n * <br>Example: <code>∪ {A, B, C} = S</code>\n * <br>Example: <code>∪ {{0,4}, {1}, {9}} = {0,1,4,9}</code>\n * @example\n * const A = Set.from(0, 4)\n * const B = Set.from(1)\n * const C = Set.from(9)\n * Set.union(A, B, C) // Set { 0, 1, 4, 9 }\n * const M = [A, B, C]\n * Set.union(...M) // Set { 0, 1, 4, 9 }\n * @name Set.union\n * @function\n * @param args {...Set} - an arbitrary list of Set instances\n * @throws Throws an error if any of the arguments is not a Set instance.\n * @returns {Set} a Set instance with the unified elements of the given args.\n * @see https://en.wikipedia.org/wiki/Union_(set_theory)#Arbitrary_unions\n */\nfunction unionArbitrary (...args) {\n  checkSets(args)\n  const set3 = new Set()\n  args.forEach(set => set.forEach(value => set3.add(value)))\n  return set3\n}\n\nglobal.Set.union = unionArbitrary\n\n/**\n * Creates the set union of two sets.\n * The union of A and B is the set C that consists of all elements of A and B.\n * <br>Expression: <code>A ∪ B = C</code>\n * <br>Example: <code>{1,2} ∪ {1,7,8,9} = {1,2,7,8,9}</code>\n * @example\n * const A = Set.from(1, 2)\n * const B = Set.from(1, 7, 8, 9)\n * A.union(B) // Set { 1, 2, 7, 8, 9 }\n * @name Set.prototype.union\n * @function\n * @param args {set} - the other set to union with.\n * @throws Throws an error if there is not exactly one argument.\n * @throws Throws an error if the argument is not a Set instance.\n * @returns {Set} a Set instance with the unified elements of the given args.\n * @see https://en.wikipedia.org/wiki/Union_(set_theory)#Union_of_two_sets\n */\nglobal.Set.prototype.union = arbitraryToBinary(unionArbitrary)\n\n/**\n * Creates the set intersection of an arbitrary number of sets.\n * The intersection S of any number of sets M<sub>i</sub> is the set whose elements consist of the elements that occur in every single set M<sub>i</sub>.\n * <br>Expression: <code>∩ M = S</code>\n * <br>Example: <code>∩ {M_1, M_2, M_3} = S</code>\n * <br>Example: <code>∩ {A, B, C} = S</code>\n * <br>Example: <code>∩ {{0,1,2,4}, {1,2,9}, {0,1,2}} = {1,2}</code>\n * @example\n * const A = Set.from(0, 1, 2, 4)\n * const B = Set.from(1, 2, 9)\n * const C = Set.from(0, 1, 2)\n * Set.intersection(A, B, C) // Set { 1, 2 }\n * const M = [A, B, C]\n * Set.intersection(...M) // Set { 1, 2 }\n * @name Set.intersection\n * @function\n * @param args {...Set}- an arbitrary list of Set instances\n * @throws Throws an error if any of the arguments is not a Set instance.\n * @returns {Set} a Set instance with the shared elements of the given args.\n * @see https://en.wikipedia.org/wiki/Intersection_(set_theory)#Arbitrary_intersections\n */\nfunction intersectionArbitrary (...args) {\n  checkSets(args)\n  if (!args || args.length === 0) {\n    throw new Error(`The intersection operator currently does not support 0 arguments.`)\n  }\n  const set3 = new Set()\n\n  const minimumSet = args.reduce((prev, curr) => {\n    return (prev.size < curr.size) ? prev : curr\n  }, args[0])\n\n  for (let value of minimumSet) {\n    if (args.every(compare => compare.has(value))) {\n      set3.add(value)\n    }\n  }\n  return set3\n}\n\nglobal.Set.intersection = intersectionArbitrary\n\n/**\n * Creates the set intersection of two sets.\n * The intersection S of sets A and B is the set whose elements consist of the elements that occur in both A and B.\n * <br>Expression: <code>A ∩ B = S</code>\n * <br>Example: <code>{0,1,2,4} ∩ {1,2,9} = {1,2}</code>\n * @example\n * const A = Set.from(0, 1, 2, 4)\n * const B = Set.from(1, 2, 9)\n * A.intersect(B) // Set { 1, 2 }\n * @name Set.prototype.intersect\n * @function\n * @param args {set} - the other set to intersect with.\n * @throws Throws an error if there is not exactly one argument.\n * @throws Throws an error if the argument is not a Set instance.\n * @returns {Set} a Set instance with the shared elements of this set and the other set.\n * @see https://en.wikipedia.org/wiki/Intersection_(set_theory)#Definition\n */\nglobal.Set.prototype.intersect = arbitraryToBinary(intersectionArbitrary)\n\n/**\n * Computes the set difference of two sets (subtracts B from A): <code>C = A \\ B</code>.  This is also known as the \"relative complement\".\n *\n * @name Set.difference\n * @function\n * @throws Throws an error if any of the arguments is not a Set instance.\n * @param set1 - A the set to be subtracted from\n * @param set2 - B the set whose elements will be subtracted from A\n * @returns {ExtendedSet|*} A new Set with all elements of A minus the elements of B\n */\nfunction difference (set1, set2) {\n  checkSet(set1)\n  checkSet(set2)\n  const set3 = new Set([])\n  set1.forEach(value => {\n    if (!set2.has(value)) {\n      set3.add(value)\n    }\n  })\n  return set3\n}\n\nglobal.Set.difference = difference\n\n/**\n * Computes the complement of set B where U is the universe: <code>C = U \\ B</code>.  This is also known as the \"absolute complement\".\n *\n * @name Set.complement\n * @function\n * @throws Throws an error if any of the arguments is not a Set instance.\n * @throws Throws an error if any element in B does not occur in U.\n * @param set1 - U the set to be subtracted from\n * @param set2 - B the set whose elements will be subtracted from A\n * @returns {ExtendedSet|*} A new Set with all elements of U minus the elements of B\n */\nfunction complement (set1, set2) {\n  checkSet(set1)\n  checkSet(set2)\n  if (!set1.isSupersetOf(set2)) {\n    throw new Error(`[set2] has an element which is not in the universe [set1].`)\n  }\n  return Set.difference(set1, set2)\n}\n\nglobal.Set.complement = complement\n\n/**\n *\n * @private\n */\nfunction symDiff (set1, set2) {\n  const set3 = new Set()\n\n  function addToSet (source, compare, target) {\n    source.forEach(value => {\n      if (!compare.has(value)) {\n        target.add(value)\n      }\n    })\n  }\n\n  addToSet(set1, set2, set3)\n  addToSet(set2, set1, set3)\n  return set3\n}\n\n/**\n * Creates the symmetric difference (disjunctive union) of an arbitrary number (2 .. n) of sets.\n * The symmetric difference of two sets A and B is a set, that contains only those elements,\n * which are in either of the sets and not in their intersection.\n * The symmetric difference is commutative and associative, which is why arbitrary number of sets can be used as input\n * for a sequencial-computed symmetric difference.\n * <br>\n * Expression: <code>C = A Δ B</code>\n *\n * @function\n * @name Set.symDiff\n * @param args {...Set}- An arbitrary amount of Set instances\n * @example\n * const a = Set.from(1,2,3)\n * const b = Set.from(3,4)\n * Set.symDiff(a, b) // Set { 1, 2, 4 }\n * @throws Throws an error if any of the given arguments is not a set instance.\n * @returns {Set} Returns a new Set, that contains only elements.\n * @see https://en.wikipedia.org/wiki/Symmetric_difference\n */\nfunction symmetricDifference (...args) {\n  args.forEach(arg => checkSet(arg))\n\n  if (args.length === 2) {\n    return symDiff(...args)\n  }\n\n  let set3 = symDiff(args.shift(), args.shift())\n  while (args.length > 0) {\n    set3 = symDiff(set3, args.shift())\n  }\n  return set3\n}\n\nglobal.Set.symDiff = symmetricDifference\n\n/**\n * Creates the cartesian product of two given sets.\n * The cartesian product of two sets A and B is the set of all ordered pairs (a, b) where a ∈ A and b ∈ B.\n * <br>\n * Expression: <code>C = A x B = { (a, b) | a ∈ A and b ∈ B}</code>\n * <br>\n * Note, that <code>A x B ≠ B x A</code> (not commutative)\n * @function\n * @name Set.cartesian\n * @param set1 {Set} - A set instance\n * @param set2 {Set} - A set instance\n * @example\n * const a = Set.from(1,2)\n * const b = Set.from(3,4)\n * Set.cartesian(a, b) // Set { [1, 3], [1, 4], [2, 3], [2, 4] }\n * Set.cartesian(b, a) // Set { [3, 1], [3, 2], [4, 1], [4, 2] }\n * @throws Throws an error unless both arguments are set instances.\n * @return {Set} a new set instance, that contains the ordered element pairs.\n * @see https://en.wikipedia.org/wiki/Cartesian_product\n */\nglobal.Set.cartesian = function cartesianProduct (set1, set2) {\n  checkSet(set1)\n  checkSet(set2)\n  const set3 = new Set()\n  set1.forEach(value1 => set2.forEach(value2 => set3.add([value1, value2])))\n  return set3\n}\n\n/**\n * https://en.wikipedia.org/wiki/Power_set\n * @private\n */\nfunction addToSubset (e, T) {\n  T.forEach(X => X.add(e))\n  return T\n}\n\n/**\n * https://en.wikipedia.org/wiki/Power_set\n * @private\n */\nfunction subsets (S, output = new Set()) {\n  checkSet(S)\n  if (S.size === 0) {\n    return Set.from(S)\n  }\n\n  const it = S.values()\n\n  let result = it.next()\n  while (!result.done) {\n    const e = result.value\n    const eSet = Set.from(e)\n\n    // get difference between first element and the rest\n    const diff = Set.difference(S, eSet)\n    output.add(diff)\n\n    // recursion: get subsets for the difference, too\n    const subs = subsets(diff)\n    subs.forEach(entry => output.add(entry))\n\n    result = it.next()\n  }\n  return output\n}\n\n/**\n * Creates the powerset of a given set instance by using a recursive algorithm (see <a href=\"https://en.wikipedia.org/wiki/Power_set\">Wikipedia</a>, section Algorithms).\n * The powerset of a set contains all possible subsets of the set, plus itself and the empty set.\n * <br>\n * <strong>Attention:</strong> This method grows exponentially with the size of the given set.\n * @name Set.power\n * @function\n * @param set {Set} - A Set instance.\n * @throws\n * Throws an error if the given set is not a set instance.\n * @returns {Set} a new set instance with all subsets of the given set, plus the given set itself and the empty set.\n * @see https://en.wikipedia.org/wiki/Power_set\n */\nfunction powerSet (set) {\n  checkSet(set)\n\n  const subs = subsets(set)\n  subs.add(new Set())\n  subs.add(set)\n  set.forEach(value => subs.add(Set.from(value)))\n  return subs\n}\n\nglobal.Set.power = powerSet\n\n/**\n * Merges two rules functions with a strict pass concept.\n * The resulting function requires the given element to pass at least one of the given functions (logical OR).\n * @function\n * @name Set.mergeRules\n * @throws Throws an error if any of the given parameters is not a Function\n * @param rules {...Function} - An arbitrary amount of (rules-) functions. See {@link Set.prototype.rules} for requirements of a rules function.\n * @returns {function(*=): boolean} The resulting rules function that can be attached to a set instance.\n * @see Set.prototype.rules\n *\n */\nfunction mergeRules (...rules) {\n  checkRules(rules)\n  return value => {\n    let passed = rules.some(rule => rule.call(value))\n    if (!passed) {\n      throw new Error(`Value [${value}] does not match any rule of the ruleset.`)\n    }\n    return true\n  }\n}\n\nglobal.Set.mergeRules = mergeRules\n\n/**\n * Merges two rules functions with a strict pass concept.\n * The resulting function requires the given element to pass all of the given functions (logical AND).\n * Thus, if the element fails one, it fails all.\n * <strong>Attention:</strong> If passed rules are mutually exclusive, none given element will pass the test in any circumstance.\n * @function\n * @name Set.mergeRulesStrict\n * @throws Throws an error if any of the given parameters is not a Function\n * @param rules {...Function} - An arbitrary amount of (rules-) functions. See {@link Set.prototype.rules} for requirements of a rules function.\n * @returns {function(*=): boolean} The resulting rules function that can be attached to a set instance.\n * @see Set.prototype.rules\n */\nfunction mergeRulesStrict (...rules) {\n  checkRules(rules)\n  return value => {\n    let passed = rules.every(rule => rule.call(value))\n    if (!passed) {\n      throw new Error(`Value [${value}] does not match any rule of the ruleset.`)\n    }\n    return true\n  }\n}\n\nglobal.Set.mergeRulesStrict = mergeRulesStrict\n\n/**\n * Flag to indicate the presence of this polyfill\n * @type {boolean}\n * @private\n */\nglobal.Set.__isExtended__ = true\n"],"file":"index.js"}